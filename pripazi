1. 
The real problem (and what I’d fix)
What is problematic is that app initialization is blocked waiting for a user response even during the lockout window, and the UI forces the user to wait and prevents pre-typing.
You’ve got two good options (pick based on desired UX):
Option A (recommended): backend waits out the cooldown before prompting
If cooldown is active, don’t call customPasswordPrompt yet.
Instead: show a status (“Too many attempts, waiting 4:37…”) and await sleep(remainingSeconds); then prompt normally.
Pros
No “disabled password dialog” while locked.
Backend isn’t stuck awaiting a renderer response during lockout.
Clearer separation: cooldown is a state, password prompt is an action.
Cons
Slightly more backend logic.
Option B: keep prompt visible but allow typing during cooldown (submit still disabled)
Change UI so the password input is enabled during cooldown, but the submit button remains disabled until timer hits 0.
Pros
Minimal backend changes.
Better UX: user can paste/type while waiting; at 0 they just hit submit.
Still secure: brute force is still blocked by submit lockout.
Cons
Still “startup blocked” (by design) until the user submits; but at least it feels responsive.

2. Timestamp forgery - ca ako korisnici sami mijenjaju timestamp

2.5 what if a user changes public keys

2.75 if Alice set the expiration to Thursday and she isnt online from wendesday to Saturday, what stops Bob from accepting the invite on Friday and just setting the timestamp (in the acceptance message) to a timestamp from Thursday when it wasnt expired? Alice will log in on Saturday and see the invitation timestamp is from Thursday. But wait, the invitation will be in the offline bucket -> does the bucket provide the actual timestamp of when the message arrived? if yes, then that could work. If no, maybe we can add logic to the validator that checks if the timestamp being put into the DHT is less than 60 seconds apart from the current timestamp (to account for latency) 


3. Animations!
3.1 paginacija poruka

4. drag and drop bootstrap nodeova za redoslijed spajanja

5.     const signFields = {
      type: 'key_exchange' as const,
      content: 'key_exchange_init' as const,
      ephemeralPublicKey: Buffer.from(ephemeralPublicKey).toString('base64'),
      senderUsername: currentUsername,
      messageBody: message,
      timestamp,
    };
    ovo gori je redundantno. umjesto da content bude keyexchangeinit, neka to prijede u type i neka se samo type gleda pa ces moc maknut messagebody


Should I save the information about a message being "offline" to show for later? its not hard, but im not sure how useful. maybe as last feature

6. PUT to DHT - Key: /kiyeovo-offline/test-shared-secret/Fnct1g9tDqVB7vFXN2QLoDLAKPIKzruAARCVT4gFscY, Original: 1938 bytes -> je li ovaj bucket zapravo uvijek isti za sve trusted korisnike? ako stavi isti secret naravno. vjv da. treba to napomenut u warningu

7.  Offline message desync after "Delete chat & user"

8. Deprecated paeketi

9. npx electron-rebuild jer je bettersqlite na nekoj staroj verziji

10. prva poruka u sesiji nemore bit file - Also, I found a bug where I cant send a file as a first message in a session because it says "key exchange init signature verification failed" - remember, the key exchange happens at the beginning of every session, not just the first ever contact

11. dok alice ceka boba da prihvati file exchange dok je prva poruka, nemore slat poruke

12. kada pukne file transfer, download ostane zauvik na 0

13. Ikona i naziv aplikacije

13.5 Stavi u README da se poveca SCRYPTN_N

14. relay nodeove
Hybrid = 2 Networks?

  Not necessarily. libp2p supports multiple addresses per peer. A single peer can be reachable via:

  Peer QmAlice:
    - /onion3/abc...xyz:9001/p2p/QmAlice           (Tor)
    - /ip4/1.2.3.4/tcp/4001/p2p/QmRelay/p2p-circuit/p2p/QmAlice  (Relay)
    - /ip4/5.6.7.8/tcp/9001/p2p/QmAlice            (Direct, if public)

  Same DHT, multiple transports. The question is: can different modes talk to each other?

  ---
  Architecture Options

  Option A: Isolated Modes (Simpler)

  ┌─────────────────────────────────────────────────────────────┐
  │                      Tor Network                             │
  │  ┌───────┐      ┌───────────┐      ┌───────┐                │
  │  │ Alice │◄────►│ Bootstrap │◄────►│  Bob  │                │
  │  │ (Tor) │      │   (Tor)   │      │ (Tor) │                │
  │  └───────┘      └───────────┘      └───────┘                │
  └─────────────────────────────────────────────────────────────┘

  ┌─────────────────────────────────────────────────────────────┐
  │                     Relay Network                            │
  │  ┌───────┐      ┌───────────┐      ┌───────┐                │
  │  │ Carol │◄────►│ Bootstrap │◄────►│ David │                │
  │  │(Relay)│      │  (Relay)  │      │(Relay)│                │
  │  └───────┘      └───────────┘      └───────┘                │
  └─────────────────────────────────────────────────────────────┘

  Alice ✗ cannot reach Carol (different networks)

  Pros: Simple, clean separation, strong anonymity for Tor users
  Cons: Network fragmentation - Tor users can not message Relay users

  ---
  Option B: Bridge via Bootstrap (More Complex)

                      ┌─────────────────────┐
                      │   Bootstrap Node    │
                      │  ┌───────────────┐  │
      Tor Network ────┼──│ Tor Hidden Svc│  │
                      │  └───────┬───────┘  │
                      │          │          │
                      │  ┌───────▼───────┐  │
    Relay Network ────┼──│ Circuit Relay │  │
                      │  └───────────────┘  │
                      └─────────────────────┘

  Alice (Tor) ──► Bootstrap ──► Carol (Relay)

  Pros: All users can communicate
  Cons:
  - Bootstrap sees message metadata (who talks to whom)
  - Adds latency for cross-mode messages
  - More trust in bootstrap operators

  ---
  Option C: User Choice per Conversation

  Alice has both Tor and Relay enabled:
    - Announces both addresses
    - Talks to Bob (Tor-only) via Tor
    - Talks to Carol (Relay-only) via Relay
    - Talks to David (both) via Relay (faster) or Tor (user choice)

  Pros: Maximum flexibility
  Cons: More complexity, resource usage (running both Tor and relay client)

  ---
  My Recommendation

  Start with Option A (Isolated) with path to Option C:

  1. Phase 1: Add Relay mode as alternative to Tor
    - User picks mode at setup: "Privacy (Tor)" vs "Performance (Relay)"
    - Separate networks, no cross-talk
    - Simple to implement
  2. Phase 2: Allow dual-mode for power users
    - Run both Tor and Relay simultaneously
    - Announce both addresses
    - Can reach anyone
  3. File transfers:
    - Tor mode: 5MB limit
    - Relay mode: No limit

  ---
  What Changes Are Needed?

  | Component     | Tor Mode (Existing) | Relay Mode (New)   |
  |---------------|---------------------|--------------------|
  | Transport     | TorTransport + TCP  | TCP + CircuitRelay |
  | NAT Traversal | Hidden Service      | Circuit Relay v2   |
  | Bootstrap     | Onion address       | Relay address      |
  | Announce      | /onion3/...         | /p2p-circuit/...   |
  | File limit    | 5MB                 | Unlimited          |



15. app security
1. sandbox: false (line 122)
sandbox: false // Need to disable sandbox for IPC to work properly
This comment is outdated. With modern Electron (v20+), contextIsolation: true + preload script works fine WITH sandbox enabled. Sandbox adds an extra layer of OS-level isolation. You should test with sandbox: true - it should work.

2. No CSP for production

For production builds, you should add a CSP. Options:
- Add <meta> tag in your index.html
- Or set it programmatically via Electron session API

Example strict CSP for production:
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'">

3. DevTools in production?

Line 139 opens DevTools in dev mode - that is fine. Just make sure isDev() correctly returns false in packaged builds.


