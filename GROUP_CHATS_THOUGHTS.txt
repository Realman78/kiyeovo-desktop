This is a file where I lay out my thoughts on the group chats functionality in Kiyeovo p2p decentralized messenger.

I was thinking max 8 members, but maybe up it to 10 (we will see what limitations arise).
A user can create a group chat only with users that he has interacted before with, so let's call them trusted users. 
Of course, a user can block group invitations. 
Since the users do not have to be online to receive a notification, we need to give them a few hours to respond (I think 6 hours is OK).
    - Why not infinite time to respond? Well, if we do that, we risk the invitation just getting lost because that bucket is no longer active (because of a potentially small network)
In the current implementation for the CLI version, a temporary key is made for those 6 hours that is used to encrypt/decrypt the messages. 
After the 6 hours pass, a new key is created to prevent users that did not accept the group invitation from reading further messages. Let's call this "group establishment".
That key is generated by the creator
    - when? the first time he opens up the app after those 6 hours
    - how is it sent? we will discuss it later, but my favorite is delivered to separate offline buckets (or sent directly if they are online)
The receivers cannot establish the group. If those 6 hours pass and they are online, the group is just waiting for the creator to come online.
In case all users accept before the timeline, the creator can establish the group without waiting for the 6 hours (optional). 
    - IMPORTANT: we have to take into account that the app is open sourced and that the creator can modify any part of code and we should think about that in case the creator is malicious
        - However, if the invite is accepted, a certain type of trust is assumed
If a receiver does not answer or rejects the invitation, he will simply not get the established group key.

Regarding how users will be notified about group invitations, I see 2 possibilities:
1. Shared notification bucket
    - The benefit here is that all users can see exactly which users are also invited
    - Users would then submit acceptances/rejections and that would update the bucket entry
    - to prevent non-invited users from modifying the bucket content, the shared bucket will be called /notifications/USER1_PUBLIC_SIGNING_KEY/USER2_PUBLIC_SIGNING_KEY/...
        - basically, similar to offline messages buckets
        - the only issue here is that one of the group members can be compromised and ruin the group, but that is why you can only invite trusted users (trusted does not mean trusted_out_of_band in this context)
2. Use the existing offline messages bucket
    - The benefit here is that this already exists, every chat has an offline bucket
    - No race conditions
    - Offline bucket is used for offline messages, but it will be converted to also accept a type of notification
    - Group creator would send out invites to the offline buckets
    - We would have to set up a polling mechanism to check the offline buckets every N seconds
    - Receivers would send a response back to the creator 


I think that is it regarding group creation and establishment. Let's move onto message sending.

Message sending will be done using gossipsub (PubSub). Online users will receive messages normally. 
Offline messages -> a shared offline bucket key: /offline/shared-secret/USER1_PUBLIC_SIGNING_KEY/USER2_PUBLIC_SIGNING_KEY/...
    - we will put a limit of 100 on the number of messages in that bucket. Maybe DHT will support even to a 1000 (bigger is better because group chats can get noisy)
    - What about the users that dont come online during those 100 messages? do they just never see older messages?
        - Unfortunately, yes. Since we will probably track who read what message, we can count the missed messages, but it's probably not necessary.
    - How will we keep track of who read what? For message deletion purposes.
        - Hm, what if we don't? we can just let the messages go away after hitting the limit, right? is a big bucket a problem? I dont think so
        - The users can just have a "cursor" saved locally that tell them the last read timestamp, and when they open up the app and check offline group messages, they can use the cursor to fetch from a certain point.

